{"version":3,"sources":["webpack://VPTStream/webpack/universalModuleDefinition","webpack://VPTStream/./src/shaders/cutout.frag","webpack://VPTStream/./src/shaders/cutout.vert","webpack://VPTStream/./src/shaders/ortho.frag","webpack://VPTStream/./src/shaders/ortho.vert","webpack://VPTStream/./src/shaders/perspective.frag","webpack://VPTStream/./src/shaders/perspective.vert","webpack://VPTStream/./src/vptstream.js","webpack://VPTStream/webpack/bootstrap","webpack://VPTStream/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","rgbdFrag","rgbdVert","orthoFrag","orthoVert","cutoutFrag","cutoutVert","schema","videoPath","type","meta","defaults","startat","default","renderMode","depthMin","depthMax","pointSize","scale","textureSize","w","h","thresholdMin","x","y","z","thresholdMax","STREAMEVENTS","Object","freeze","PLAY_SUCCESS","PLAY_ERROR","LOAD_ERROR","NETWORK_ERROR","MEDIA_ERROR","HLS_ERROR","VPTStream","THREE","Object3D","super","this","video","createVideoEl","texture","VideoTexture","minFilter","NearestFilter","magFilter","LinearFilter","format","RGBFormat","hls","hls_xhroverride","loadTime","playing","meshScalar","params","param","value","currentTime","material","uniforms","console","log","property","hasOwnProperty","setProps","error","extrinsics","Matrix4","ex","props","set","dispose","child","getObjectByName","remove","startVideo","geometry","PlaneBufferGeometry","ShaderMaterial","extensions","derivatives","side","DoubleSide","vertexShader","fragmentShader","transparent","pointsO","Points","position","name","add","plane","Mesh","depthFocalLength","depthPrincipalPoint","depthImageSize","textureWidth","textureHeight","pointP","rgbdVert_rs2","rgbdFrag_rs2","pointPRL2","filePath","Promise","resolve","reject","jsonLoader","FileLoader","manager","setResponseType","load","data","err","_props","undefined","e00","e01","e02","e03","e10","e11","e12","e13","e20","e21","e22","e23","e30","e31","e32","e33","crop","play","then","dispatchEvent","message","catch","stop","volume","time","_material","el","document","createElement","setAttribute","autoplay","muted","preload","crossOrigin","ratio","width","Math","min","height","object3DMap","mesh","matrixNeedsUpdate","image","HTMLVideoElement","pause","src","stopLoad","detachMedia","destroy","videoUrl","Hls","isSupported","xhrSetup","loadSource","attachMedia","on","Events","ERROR","event","fatal","ErrorTypes","startLoad","recoverMediaError","MANIFEST_PARSED","performance","now","_this","setupHls","canPlayType","contentType","onerror","failLoad","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"mappings":"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","file":"vptstream.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VPTStream\"] = factory();\n\telse\n\t\troot[\"VPTStream\"] = factory();\n})(self, function() {\nreturn ","module.exports = \"uniform sampler2D map;\\nuniform float opacity;\\nuniform float width;\\nuniform float height;\\nuniform float depthMin;\\nuniform float depthMax;\\nuniform vec3 thresholdMin;\\nuniform vec3 thresholdMax;\\n\\nvarying vec2 vUv;\\n\\n#define BRIGHTNESS_THRESHOLD_OFFSET 0.01\\n#define FLOAT_EPS 0.00001\\n\\nconst float _DepthSaturationThreshhold = 0.3; //a given pixel whose saturation is less than half will be culled (old default was .5)\\nconst float _DepthBrightnessThreshold = 0.4; //a given pixel whose brightness is less than half will be culled (old default was .9)\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n  float d = q.x - min(q.w, q.y);\\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + FLOAT_EPS)), d / (q.x + FLOAT_EPS), q.x);\\n}\\n\\nvoid main() {\\n\\n  float verticalScale = 0.5;//480.0 / 720.0;\\n  float verticalOffset = 1.0 - verticalScale;\\n\\n  vec2 colorUv = vUv * vec2(1.0, verticalScale) + vec2(0.0, 0.5);\\n  vec2 depthUv = colorUv - vec2(0.0, 0.5);\\n\\n  vec4 colorSample = texture2D(map, colorUv); \\n  vec4 depthSample = texture2D(map, depthUv); \\n\\n  vec3 hsv = rgb2hsv(depthSample.rgb);\\n  float depth = hsv.b > _DepthBrightnessThreshold + BRIGHTNESS_THRESHOLD_OFFSET ? hsv.r : 0.0;\\n  float z = depth * (depthMax - depthMin) + depthMin;\\n  float alpha = depth > 0.0 && z > thresholdMin.z && z < thresholdMax.z ? 1.0 : 0.0;\\n\\n  if(alpha <= 0.0) {\\n    discard;\\n  }\\n\\n  colorSample.a *= (alpha * opacity);\\n\\n  gl_FragColor = colorSample;\\n}\"","module.exports = \"varying vec2 vUv;\\nuniform float pointSize;\\nuniform float depthMin;\\nuniform float depthMax;\\nuniform float scale;\\nuniform vec3 thresholdMin;\\nuniform vec3 thresholdMax;\\n\\nvoid main()\\n{\\n  vUv = uv;\\n  gl_Position =  projectionMatrix * modelViewMatrix * vec4(position,1.0);\\n}\"","module.exports = \"uniform sampler2D map;\\nuniform float opacity;\\nuniform float width;\\nuniform float height;\\nuniform float depthMin;\\nuniform float depthMax;\\nuniform vec3 thresholdMin;\\nuniform vec3 thresholdMax;\\n\\nvarying vec4 ptColor;\\nvarying vec2 vUv;\\nvarying vec3 debug;\\n\\n#define BRIGHTNESS_THRESHOLD_OFFSET 0.01\\n#define FLOAT_EPS 0.00001\\n\\nconst float _DepthSaturationThreshhold = 0.3; //a given pixel whose saturation is less than half will be culled (old default was .5)\\nconst float _DepthBrightnessThreshold = 0.6; //a given pixel whose brightness is less than half will be culled (old default was .9)\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n    float d = q.x - min(q.w, q.y);\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + FLOAT_EPS)), d / (q.x + FLOAT_EPS), q.x);\\n}\\n\\nfloat depthForPoint(vec2 texturePoint)\\n{\\n    vec4 depthsample = texture2D(map, texturePoint);\\n    vec3 depthsamplehsv = rgb2hsv(depthsample.rgb);\\n    return depthsamplehsv.g > _DepthSaturationThreshhold && depthsamplehsv.b > _DepthBrightnessThreshold ? depthsamplehsv.r : 0.0;\\n}\\n\\nvoid main() {\\n\\n  /*float verticalScale = 480.0 / 720.0;\\n  float verticalOffset = 1.0 - verticalScale;\\n  vec2 colorUv = vUv * vec2(0.5, verticalScale) + vec2(0, verticalOffset);\\n  vec2 depthUv = colorUv + vec2(0.5, 0.0);*/\\n\\n\\n    float verticalScale = 0.5;//480.0 / 720.0;\\n    float verticalOffset = 1.0 - verticalScale;\\n\\n    vec2 colorUv = vUv * vec2(1.0, verticalScale) + vec2(0.0, 0.5);\\n    vec2 depthUv = colorUv - vec2(0.0, 0.5);\\n\\n    vec4 colorSample = ptColor;// texture2D(map, colorUv); \\n    vec4 depthSample = texture2D(map, depthUv); \\n\\n    vec3 hsv = rgb2hsv(depthSample.rgb);\\n    float depth = hsv.b > _DepthBrightnessThreshold + BRIGHTNESS_THRESHOLD_OFFSET ? hsv.r : 0.0;\\n    float z = depth * (depthMax - depthMin) + depthMin;\\n    float alpha = depth > 0.0 && z > thresholdMin.z && z < thresholdMax.z ? 1.0 : 0.0;\\n\\n    if(alpha <= 0.0) {\\n      discard;\\n    }\\n\\n    colorSample.a *= (alpha * opacity);\\n\\n    gl_FragColor = colorSample;//vec4(debug, 1);\\n}\"","module.exports = \"uniform sampler2D map;\\n\\nuniform float pointSize;\\nuniform float depthMin;\\nuniform float depthMax;\\nuniform vec3 thresholdMin;\\nuniform vec3 thresholdMax;\\nuniform float scale;\\nvarying vec4 ptColor;\\nvarying vec2 vUv;\\nvarying vec3 debug;\\n\\nconst float _DepthSaturationThreshhold = 0.3; //a given pixel whose saturation is less than half will be culled (old default was .5)\\nconst float _DepthBrightnessThreshold = 0.3; //a given pixel whose brightness is less than half will be culled (old default was .9)\\nconst float  _Epsilon = .03;\\n\\n//https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\\nconst float SRGB_GAMMA = 1.0 / 2.2;\\nconst float SRGB_INVERSE_GAMMA = 2.2;\\nconst float SRGB_ALPHA = 0.055;\\n\\n// Converts a single srgb channel to rgb\\nfloat srgb_to_linear(float channel) {\\n  if (channel <= 0.04045)\\n      return channel / 12.92;\\n  else\\n      return pow((channel + SRGB_ALPHA) / (1.0 + SRGB_ALPHA), 2.4);\\n}\\n\\n// Converts a srgb color to a linear rgb color (exact, not approximated)\\nvec3 srgb_to_rgb(vec3 srgb) {\\n  return vec3(\\n      srgb_to_linear(srgb.r),\\n      srgb_to_linear(srgb.g),\\n      srgb_to_linear(srgb.b)\\n  );\\n}\\n\\n//faster but noisier\\nvec3 srgb_to_rgb_approx(vec3 srgb) {\\nreturn pow(srgb, vec3(SRGB_INVERSE_GAMMA));\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n  float d = q.x - min(q.w, q.y);\\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + _Epsilon)), d / (q.x + _Epsilon), q.x);\\n}\\n\\n\\nfloat depthForPoint(vec2 texturePoint)\\n{\\n  vec4 depthsample = texture2D(map, texturePoint);\\n  vec3 linear = srgb_to_rgb( depthsample.rgb);\\n  vec3 depthsamplehsv = rgb2hsv(linear.rgb);\\n  return depthsamplehsv.g > _DepthSaturationThreshhold && depthsamplehsv.b > _DepthBrightnessThreshold ? depthsamplehsv.r : 0.0;\\n}\\n\\nvoid main()\\n{\\n  float mindepth = depthMin;\\n  float maxdepth = depthMax;\\n\\n  float verticalScale = 0.5;//480.0 / 720.0;\\n  float verticalOffset = 1.0 - verticalScale;\\n\\n  vec2 colorUv = uv * vec2(1.0, verticalScale) + vec2(0.0, 0.5);\\n  vec2 depthUv = colorUv - vec2(0.0, 0.5);\\n\\n  float depth = depthForPoint(depthUv);\\n\\n  float z = depth * (maxdepth - mindepth) + mindepth;\\n  \\n  vec4 worldPos = vec4(position.xy, -z, 1.0);\\n  worldPos.w = 1.0;\\n\\n  vec4 mvPosition = vec4( worldPos.xyz, 1.0 );\\n  mvPosition = modelViewMatrix * mvPosition;\\n\\n  ptColor = texture2D(map, colorUv);\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * worldPos;\\n  vUv = uv;\\n  debug = vec3(1, 0.5, 0.0);\\n  \\n  gl_PointSize = pointSize;\\n  gl_PointSize *= ( scale / - mvPosition.z );\\n\\n  //gl_Position =  projectionMatrix * modelViewMatrix * vec4(position,1.0);\\n}\"","module.exports = \"\\nuniform sampler2D map;\\nuniform float opacity;\\nuniform float width;\\nuniform float height;\\n\\nvarying vec4 ptColor;\\nvarying vec2 vUv;\\nvarying vec3 debug;\\n\\nvoid main() {\\n\\n    if( ptColor.a <= 0.0){\\n        discard;\\n    }\\n\\n    vec4 colorSample = ptColor;\\n    colorSample.a *= (ptColor.a * opacity);\\n\\n    gl_FragColor = colorSample;\\n}\"","module.exports = \"\\nuniform vec2 focalLength;//fx,fy\\nuniform vec2 principalPoint;//ppx,ppy\\nuniform vec2 imageDimensions;\\nuniform mat4 extrinsics;\\nuniform float width;\\nuniform float height;\\nuniform float scale;\\nuniform sampler2D map;\\n\\nuniform float pointSize;\\nuniform float depthMin;\\nuniform float depthMax;\\nuniform vec3 thresholdMin;\\nuniform vec3 thresholdMax;\\nvarying vec4 ptColor;\\nvarying vec2 vUv;\\nvarying vec3 debug;\\n\\nconst float _DepthSaturationThreshhold = 0.3; //a given pixel whose saturation is less than half will be culled (old default was .5)\\nconst float _DepthBrightnessThreshold = 0.3; //a given pixel whose brightness is less than half will be culled (old default was .9)\\nconst float  _Epsilon = .03;\\n\\n#define BRIGHTNESS_THRESHOLD_OFFSET 0.01\\n#define FLOAT_EPS 0.00001\\n#define CLIP_EPSILON 0.005\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n    float d = q.x - min(q.w, q.y);\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + FLOAT_EPS)), d / (q.x + FLOAT_EPS), q.x);\\n}\\n\\nfloat depthForPoint(vec2 texturePoint)\\n{       \\n    vec2 centerpix = vec2(1.0/width, 1.0/height) * 0.5;\\n    texturePoint += centerpix;\\n\\n    // clamp to texture bounds - 0.5 pixelsize so we do not sample outside our texture\\n    texturePoint = clamp(texturePoint, centerpix, vec2(1.0, 0.5) - centerpix);\\n    vec4 depthsample = texture2D(map, texturePoint);\\n    vec3 depthsamplehsv = rgb2hsv(depthsample.rgb);\\n    return depthsamplehsv.b > _DepthBrightnessThreshold + BRIGHTNESS_THRESHOLD_OFFSET ? depthsamplehsv.r : 0.0;\\n}\\n\\n//https://stackoverflow.com/questions/12751080/glsl-point-inside-box-test/37426532\\nfloat insideBox3D(vec3 v, vec3 bottomLeft, vec3 topRight) {\\n    vec3 s = step(bottomLeft, v) - step(topRight, v);\\n    return s.x * s.y * s.z; \\n}\\n\\nvoid main()\\n{   \\n    vec4 texSize = vec4(1.0 / width, 1.0 / height, width, height);\\n    vec2 basetex = position.xy + vec2(0.5,0.5);\\n\\n    // we align our depth pixel centers with the center of each quad, so we do not require a half pixel offset\\n    vec2 depthTexCoord = basetex * vec2(1.0, 0.5);\\n    vec2 colorTexCoord = basetex * vec2(1.0, 0.5) + vec2(0.0, 0.5);\\n\\n    float depth = depthForPoint(depthTexCoord);\\n    float mindepth = depthMin;\\n    float maxdepth = depthMax;\\n\\n    float z = depth * (maxdepth - mindepth) + mindepth;\\n    vec2 ortho = basetex * imageDimensions - principalPoint;\\n    vec2 proj = ortho * z / focalLength;\\n    vec4 worldPos = extrinsics *  vec4(proj.xy, z, 1.0);\\n    worldPos.w = 1.0;\\n\\n    vec4 mvPosition = vec4( worldPos.xyz, 1.0 );\\n    mvPosition = modelViewMatrix * mvPosition;\\n    ptColor = texture2D(map, colorTexCoord);\\n\\n    ptColor.a = insideBox3D(worldPos.xyz, thresholdMin, thresholdMax ) > 0.0 && depth > 0.0 ? 1.0 : 0.0;\\n\\n    mat4 flip = mat4(  vec4(-1.0,0.0,0.0,0.0),\\n                        vec4(0.0,1.0,0.0,0.0),\\n                        vec4(0.0,0.0,1.0,0.0),\\n                        vec4(0.0,0.0,0.0,1.0));\\n    \\n    gl_Position = projectionMatrix * modelViewMatrix * flip * worldPos;\\n    vUv = uv;\\n    debug = vec3(1, 0.5, 0.0);\\n\\n    gl_PointSize = pointSize;\\n    gl_PointSize *= ( scale / - mvPosition.z );\\n\\n}\\n\"","//VPTStream \n\n//NOTE on GLSL\n//we use webpack-glsl-loader to include the shaders (https://github.com/grieve/webpack-glsl-loader#readme)\n//which in turn depends on glslify (https://github.com/glslify/glslify)\nconst rgbdFrag = require('./shaders/perspective.frag');\nconst rgbdVert = require('./shaders/perspective.vert');\n\nconst orthoFrag = require('./shaders/ortho.frag');\nconst orthoVert = require('./shaders/ortho.vert');\n\nconst cutoutFrag = require('./shaders/cutout.frag');\nconst cutoutVert = require('./shaders/cutout.vert');\n\nconst HLS_TIMEOUT = 2500;\n\nconst schema = {\n  videoPath: { type: 'string' },\n  meta: {type: 'object', defaults: {}},\n  startat: { type: 'number', default: 0 },\n  renderMode: { type: 'string', default: 'perspective' },\n  depthMin: { type: 'number', default: 0.29 },\n  depthMax: { type: 'number', default: 4.0 },\n  pointSize: { type: 'number', default: 8.0 },\n  scale: { type: 'number', default: 1.0 },\n  textureSize: { type: 'vec2', default: {w:320, h:240} },\n  thresholdMin: { type: 'vec3', default: {x:-2.0, y:-2.0,z:0.0} }, \n  thresholdMax: { type: 'vec3', default:  {x:2.0, y:2.0,z:4.0} },\n}\n\nconst STREAMEVENTS = Object.freeze({\n  PLAY_SUCCESS: \"PLAY_SUCCESS\",\n  PLAY_ERROR: \"PLAY_ERROR\",\n  LOAD_ERROR: \"LOAD_ERROR\",\n  NETWORK_ERROR: \"NETWORK_ERROR\",\n  MEDIA_ERROR: \"MEDIA_ERROR\",\n  HLS_ERROR: \"HLS_ERROR\"\n})\n\n//Volumetric Performance Toolbox streaming player\nclass VPTStream extends THREE.Object3D {\n\n  constructor() {\n    super();\n\n    this.video = this.createVideoEl();\n    this.texture = new THREE.VideoTexture(this.video);\n    this.texture.minFilter = THREE.NearestFilter;\n    this.texture.magFilter = THREE.LinearFilter;\n    this.texture.format = THREE.RGBFormat;\n    this.hls = null;\n\n    //When using vptstream in mozilla hubs/spoke we run into issues with the proxy / cors setup and the way Hls resolves urls.\n    //Hack copied from her: https://github.com/mozilla/hubs/blob/584e48ad0ccc0da1fc9781e7686d19431a2340cd/src/components/media-views.js#L773\n    //the function params / signature is (xhr, u)  \n    this.hls_xhroverride = null;\n\n    this.loadTime = 0;\n    this.playing = false;\n    this.meshScalar = 2;\n    this.params = {}\n  }\n\n  static get STREAMEVENTS() {\n    return STREAMEVENTS;\n  }\n\n  get LoadTime() {\n    return this.loadTime;\n  }\n\n  get Playing() \n  {\n    return this.playing;\n  }\n\n  updateParameter( param, value){\n\n    if( param == \"startat\"){\n      this.video.currentTime = value;\n    }else{\n      if( this.material){\n        this.material.uniforms[param].value = value;\n      }\n    }\n\n  }\n \n  load(params) \n  {\n    console.log(\"vptstream load\");\n\n    for (const property in schema) {\n      console.log(`${property} value:${params[property]} default:${schema[property].default}`);\n      this.params[property] = params.hasOwnProperty(property) ? params[property] : schema[property].default;\n    }\n\n    if( this.params.meta.hasOwnProperty(\"depthFocalLength\") ){\n      this.setProps( this.params.meta );\n    }else{\n      console.error(\"invalid meta data for perspective rendering, default to cutout\");\n      this.params.renderMode = \"cutout\"\n    }\n\n    //so far we have not had to use custom extrinsice for Azure Kinect or Realsense\n    //default could suffice as the alignment is done upstream, when we grab if from the sensor\n    //leaving this here to allow for textures that still need alignment \n    const extrinsics = new THREE.Matrix4();\n    const ex = this.props.extrinsics;\n    extrinsics.set(\n      ex[\"e00\"], ex[\"e10\"], ex[\"e20\"], ex[\"e30\"],\n      ex[\"e01\"], ex[\"e11\"], ex[\"e21\"], ex[\"e31\"],\n      ex[\"e02\"], ex[\"e12\"], ex[\"e22\"], ex[\"e32\"],\n      ex[\"e03\"], ex[\"e13\"], ex[\"e23\"], ex[\"e33\"]\n    );\n\n    if( this.material){\n      console.log(\"Material exists, dispose\")\n      this.material.dispose();\n      const child = this.getObjectByName(\"VolumetricVideo\");\n      if( child ){\n        console.log(\"VolumetricVideo exists, remove\")\n        this.remove(child);\n      }\n    }\n\n    this.startVideo(this.params.videoPath);\n\n    let geometry = new THREE.PlaneBufferGeometry(1, 1, this.params.textureSize.w,  this.params.textureSize.h);\n    \n    switch (this.params.renderMode) {\n\n      case \"ortho\":\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            \"map\": {\n              type: \"t\",\n              value: this.texture\n            },\n            \"time\": {\n              type: \"f\",\n              value: 0.0\n            },\n            \"opacity\": {\n              type: \"f\",\n              value: 1.0\n            },\n            \"pointSize\": {\n              type: \"f\",\n              value: this.params.pointSize\n            },\n            \"depthMin\": {\n              type: \"f\",\n              value: this.params.depthMin\n            },\n            \"depthMax\": {\n              type: \"f\",\n              value: this.params.depthMax\n            },\n            \"thresholdMin\":{\n              value: this.params.thresholdMin\n            },\n            \"thresholdMax\":{\n              value: this.params.thresholdMax\n            },    \n            \"scale\": {\n              value: this.params.scale\n            },\n            extensions:\n            {\n              derivatives: true\n            }\n          },\n          side: THREE.DoubleSide,\n          vertexShader: orthoVert,\n          fragmentShader: orthoFrag,\n          transparent: true\n          //depthWrite:falses\n        });\n\n        let pointsO = new THREE.Points(geometry, this.material);\n        pointsO.position.y = 1;\n        pointsO.name = \"VolumetricVideo\";\n        this.add(pointsO);\n        break;\n\n      case \"cutout\":\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            \"map\": {\n              type: \"t\",\n              value: this.texture\n            },\n            \"time\": {\n              type: \"f\",\n              value: 0.0\n            },\n            \"opacity\": {\n              type: \"f\",\n              value: 1.0\n            },\n            \"depthMin\": {\n              type: \"f\",\n              value: this.params.depthMin\n            },\n            \"depthMax\": {\n              type: \"f\",\n              value: this.params.depthMax\n            },\n            \"thresholdMin\":{\n              value: this.params.thresholdMin\n            },\n            \"thresholdMax\":{\n              value: this.params.thresholdMax\n            },    \n            \"scale\": {\n              value: this.params.scale\n            },\n            extensions:\n            {\n              derivatives: true\n            }\n          },\n          side: THREE.DoubleSide,\n          vertexShader: cutoutVert,\n          fragmentShader: cutoutFrag,\n          transparent: true\n        });\n\n        let plane = new THREE.Mesh(geometry, this.material);\n        plane.position.y = 1;\n        plane.scale.set( this.params.textureSize.w / this.params.textureSize.h, 1.0, 1.0);\n        plane.name = \"VolumetricVideo\";\n\n        this.add(plane);\n        break;\n\n      case \"perspective\":\n        //assumes depthkit style hsv encoding\n\n        //Material\n        this.material = new THREE.ShaderMaterial({\n          uniforms: {\n            \"map\": {\n              type: \"t\",\n              value: this.texture\n            },\n            \"pointSize\": {\n              type: \"f\",\n              value: this.params.pointSize\n            },\n            \"depthMin\": {\n              type: \"f\",\n              value: this.params.depthMin\n            },\n            \"depthMax\": {\n              type: \"f\",\n              value: this.params.depthMax\n            },\n            \"scale\": {\n              value: this.params.scale\n            },\n            \"focalLength\": {\n              value: this.props.depthFocalLength\n            },\n            \"principalPoint\": {\n              value: this.props.depthPrincipalPoint\n            },\n            \"imageDimensions\": {\n              value: this.props.depthImageSize\n            },\n            \"width\":{\n              value: this.props.textureWidth\n            },\n            \"height\":{\n              value: this.props.textureHeight\n            },\n            \"thresholdMin\":{\n              value: this.params.thresholdMin\n            },\n            \"thresholdMax\":{\n              value: this.params.thresholdMax\n            },    \n            \"extrinsics\": {\n              value: extrinsics\n            },              \n            \"opacity\": {\n              type: \"f\",\n              value: 1.0\n            }\n          },\n          extensions:\n          {\n            derivatives: true,\n          },\n          vertexShader: rgbdVert,\n          fragmentShader: rgbdFrag,\n          transparent: true\n        });\n\n        //Make the shader material double sided\n        this.material.side = THREE.DoubleSide;\n        \n        let pointP = new THREE.Points(geometry, this.material);\n        pointP.name = \"VolumetricVideo\";\n        pointP.position.y = 1;\n        this.add(pointP);\n        break;\n      \n      case \"perspective_rl2\":\n       \n          //assuming librealsense2 hsv colorizer\n          //https://dev.intelrealsense.com/docs/depth-image-compression-by-colorization-for-intel-realsense-depth-cameras#section-6references\n          \n        \n          //Material\n          this.material = new THREE.ShaderMaterial({\n            uniforms: {\n              \"map\": {\n                type: \"t\",\n                value: this.texture\n              },\n              \"pointSize\": {\n                type: \"f\",\n                value: this.params.pointSize\n              },\n              \"depthMin\": {\n                type: \"f\",\n                value: this.params.depthMin\n              },\n              \"depthMax\": {\n                type: \"f\",\n                value: this.params.depthMax\n              },\n              \"scale\": {\n                value: this.params.scale\n              },\n              \"focalLength\": {\n                value: this.props.depthFocalLength\n              },\n              \"principalPoint\": {\n                value: this.props.depthPrincipalPoint\n              },\n              \"imageDimensions\": {\n                value: this.props.depthImageSize\n              },\n              \"width\":{\n                value: this.props.textureWidth\n              },\n              \"height\":{\n                value: this.props.textureHeight\n              },\n              \"thresholdMin\":{\n                value: this.params.thresholdMin\n              },\n              \"thresholdMax\":{\n                value: this.params.thresholdMax\n              }, \n              \"extrinsics\": {\n                value: extrinsics\n              },              \n              \"opacity\": {\n                type: \"f\",\n                value: 1.0\n              }\n            },\n            extensions:\n            {\n              derivatives: true,\n            },\n            vertexShader: rgbdVert_rs2,\n            fragmentShader: rgbdFrag_rs2,\n            transparent: true\n          });\n  \n          //Make the shader material double sided\n          this.material.side = THREE.DoubleSide;\n          \n          let pointPRL2 = new THREE.Points(geometry, this.material);\n          pointPRL2.name = \"VolumetricVideo\";\n          pointPRL2.position.y = 1;\n          this.add(pointPRL2);\n          break;  \n    }\n  }\n\n  //load depth camera properties for perspective reprojection\n  loadPropsFromFile(filePath) {\n    return new Promise((resolve, reject) => {\n        const jsonLoader = new THREE.FileLoader(this.manager);\n        jsonLoader.setResponseType('json');\n        jsonLoader.load(filePath, data => {\n          resolve(data);\n        }, null, err => {\n          reject(err);\n        });\n      });    \n  }\n  \n  //set perspective projection properties\n  setProps(_props) {\n    this.props = _props;\n    if (this.props.textureWidth == undefined || this.props.textureHeight == undefined) {\n      this.props.textureWidth = this.props.depthImageSize.x;\n      this.props.textureHeight = this.props.depthImageSize.y * 2;\n    }\n    if (this.props.extrinsics == undefined) {\n      this.props.extrinsics = {\n        e00: 1, e01: 0, e02: 0, e03: 0,\n        e10: 0, e11: 1, e12: 0, e13: 0,\n        e20: 0, e21: 0, e22: 1, e23: 0,\n        e30: 0, e31: 0, e32: 0, e33: 1\n      };\n    }\n    if (this.props.crop == undefined) {\n      this.props.crop = { x: 0, y: 0, z: 1, w: 1 };\n    } \n  }\n\n  play() {\n    this.video.play().then(function () {\n      this.dispatchEvent({ type: STREAMEVENTS.PLAY_SUCCESS, message: \"autoplay success\" });\n      this.playing = true;\n    }).catch(function (error) {\n      this.dispatchEvent({ type: STREAMEVENTS.PLAY_ERROR, message: \"autoplay error\" });\n      this.playing = false;\n    });\n\n    return this.playing;\n\n  }\n\n  stop() {\n    this.video.stop();\n  }\n\n  pause() {\n\n  }\n\n  setVolume(volume) {\n    this.video.volume = volume;\n  }\n\n  update(time) {\n    this._material.uniforms.time.value = time;\n  }\n\n  createVideoEl() {\n    const el = document.createElement(\"video\");\n\n    el.setAttribute(\"id\", \"volumetric-stream-video\");\n\n    el.setAttribute(\"playsinline\", \"\");\n    el.setAttribute(\"webkit-playsinline\", \"\");\n    // iOS Safari requires the autoplay attribute, or it won't play the video at all.\n    el.autoplay = true;\n    // iOS Safari will not play videos without user interaction. We mute the video so that it can autoplay and then\n    // allow the user to unmute it with an interaction in the unmute-video-button component.\n    el.muted = false;\n    el.preload = \"auto\";\n    el.crossOrigin = \"anonymous\";\n\n    console.log(\"Volumetric Stream: Video element created\", el);\n\n    return el;\n  }\n\n  scaleToAspectRatio(el, ratio) {\n    const width = Math.min(1.0, 1.0 / ratio);\n    const height = Math.min(1.0, ratio);\n    el.object3DMap.mesh.scale.set(width, height, 1);\n    el.object3DMap.mesh.matrixNeedsUpdate = true;\n  }\n\n  dispose() {\n    if (this.texture.image instanceof HTMLVideoElement) {\n      const video = this.texture.image;\n      video.pause();\n      video.src = \"\";\n      video.load();\n    }\n\n    if (this.hls) {\n      this.hls.stopLoad();\n      this.hls.detachMedia();\n      this.hls.destroy();\n      this.hls = null;\n    }\n\n    this.texture.dispose();\n    this.material.dispose();\n  }\n\n  setVideoUrl(videoUrl) {\n    if (this.hls) {\n      this.startVideo(videoUrl);\n    }\n  }\n\n  startVideo(videoUrl) {\n    console.log(\"startVideo \" + videoUrl);\n\n    if (Hls.isSupported()) {\n\n      const baseUrl = videoUrl;\n\n      const setupHls = () => {\n        if (this.hls) {\n          this.hls.stopLoad();\n          this.hls.detachMedia();\n          this.hls.destroy();\n          this.hls = null;\n        }\n\n        //do we need to hook / override Hls xhr calls to handle cors proxying\n        if( this.hls_xhroverride ){\n          this.hls = new Hls({\n            xhrSetup: this.hls_xhroverride\n          });\n\n        }else{\n          this.hls = new Hls();          \n        }\n        this.hls.loadSource(videoUrl);\n        this.hls.attachMedia(this.video);\n\n        this.hls.on(Hls.Events.ERROR, (event, data) => {\n          if (data.fatal) {\n            switch (data.type) {\n              case Hls.ErrorTypes.NETWORK_ERROR:\n                //console.log(\"NETWORK_ERROR\", data )\n                this.dispatchEvent({ type: STREAMEVENTS.NETWORK_ERROR, message: data.message });\n                // try to recover network error\n                this.hls.startLoad();\n                break;\n              case Hls.ErrorTypes.MEDIA_ERROR:\n                //console.log(\"MEDIA_ERROR\", data )\n                this.dispatchEvent({ type: STREAMEVENTS.MEDIA_ERROR, message: data.message });\n                this.hls.recoverMediaError();\n                break;\n              default:\n                //console.log(\"Hls ERROR\", data )\n                this.dispatchEvent({ type: STREAMEVENTS.HLS_ERROR, message: `hls error ${data.type} ${data.message}` });\n                return;\n            }\n          } else {\n            console.log(\"Hls non fatar error:\", data);\n            if( data.type == Hls.ErrorTypes.MEDIA_ERROR){\n              //this.hls.recoverMediaError();\n            }\n          }\n        });\n\n        this.hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {\n          this.loadTime = performance.now();\n          const _this = this;\n          this.video.play().then(function () {\n            console.log(\"Hls success auto playing \" + _this.params.startat );\n            _this.video.currentTime = _this.params.startat;\n            _this.dispatchEvent({ type: STREAMEVENTS.PLAY_SUCCESS, message: \"autoplay success\" });\n            _this.playing = true;\n          }).catch(function (error) {\n            //console.log(\"Hls error trying to auto play \" + error + \" \" + error.name);\n            _this.dispatchEvent({ type: STREAMEVENTS.PLAY_ERROR, message: \"error trying to auto play \" + error + \" \" + error.name });\n            _this.playing = false;\n          });\n        });\n      };\n\n      setupHls();\n\n    } else if (this.video.canPlayType(contentType)) {\n      this.video.src = videoUrl;\n      this.video.onerror = failLoad;\n\n      this.video.play().then(function () {\n        this.dispatchEvent({ type: STREAMEVENTS.PLAY_SUCCESS, message: \"autoplay success\" });\n      }).catch(function (error) {\n        this.dispatchEvent({ type: STREAMEVENTS.PLAY_ERROR, message: \"autoplay error\" });\n        console.log(\"error autoplay\", data);\n      });\n    } else {\n      console.log(\"Hls unsupported, can't load or play\");\n      this.dispatchEvent({ type: STREAMEVENTS.LOAD_ERROR, message: \"Hls unsupported, can't play media\" });\n    }\n  }\n}\n\nmodule.exports = VPTStream;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(979);\n"],"sourceRoot":""}